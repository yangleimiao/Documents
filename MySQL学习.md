MySQL学习

---



**MySQL的binlog有哪几种录入格式？**

statement、row和mixed

* statement模式下，每一条会修改数据的sql都会记录在binlog中；不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能；由于sql的执行有上下文，因此在保存的时候需要保存相关信息，同时还有一些使用了函数之类的语句无法被记录；
* row模式下，不记录sql语句上下文相关信息，仅保存哪条记录被修改，记录每一行的改动，日志量太大；
* mixed，一种折中方案，普通操作使用statement记录，当无法使用statement的时候使用row；



**MySQL存储引擎**

常用存储引擎有：Innodb、MyIASM和MEMORY

Innodb引擎：Innodb引擎提供了对数据库ACID事务的支持，并且还提供了行级锁和外键的约束，适用于处理大数据容量的数据库系统；

MyIASM引擎：不提供事务的支持，也不支持行级锁和外键；

MEMORY引擎：所有的数据都在内存中，数据的处理速度快但安全性不高；





**B树和B+树的区别**

B树中可以将键和值放在叶子节点和非叶子节点，但在B+树中，内部节点（非叶子节点）都是键，没有值，叶子节点同时存放键和值；

B+树的叶子节点用一条链相连，B树的叶子节点各自独立；

* 使用B树的好处

  B树可以在内部节点同时存储键和值，因此把频繁访问的数据放在靠近根节点的地方可以提高热点数据的查询效率

* 使用B+树的好处

  B+树的内部节点只存放键不放值，一次读取，可以在内存页中获取更多键，有利于更快的缩写查找范围；

  B+树的叶子节点由一条链相连，因此当需要一次全部遍历时，B+树只需要O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可，而B树则需要对树的每一层进行遍历；

**数据库为什么使用B+树而不是B树**

* B树只适合随机检索，而B+树同时支持随机检索和顺序检索；
* B+树空间利用率更高，可减少IO次数















MySQL的锁

从锁的类别分为共享锁和排它锁；

共享锁：又叫读锁，当用户要进行数据读取时，对数据加上共享锁，共享锁就是让多个线程同时获取一个锁；

排它锁：又叫写锁，当用户要进行数据写入时，对数据加上排他锁，排它锁也称作独占锁，一个锁在某一时刻只能被一个线程占有，其他线程必须等待锁被释放才能获取；



按锁的粒度分，数据库锁有哪些

按照锁的粒度分为行级锁（INNODB引擎）、表级锁（MyISAM）和页级锁（BDB）引擎

MyISAM采用表级锁；

InnoDB支持行级锁和表级锁，默认为行级锁；



行级锁、表级锁和页级锁

行级锁：是MySQL中锁定粒度最小的一种锁，表示只针对当前操作的行进行加锁，行级锁能减少数据库操作的冲突，但加锁的开销也最大；

表级锁：是锁定粒度最大的一种锁，表示对当前操作 整张表加锁，实现简单，资源消耗少；但发生锁冲突的概率最高，并发度最低；

页级锁：锁定粒度介于行级锁和表级锁中间的一种锁，表级锁速度快但冲突多，行级锁冲突少但速度慢，所以取折中的页级；













**MySQL的约束**

NOT NULL：用于控制字段的内容一定不能为空（NULL）

UNIQUE：控制字段内容不能重复，一个表允许有多个Unique约束

PRIMARY KEY：主键，控制字段不能重复，一个表只有一个

FOREIGN KEY：外键

CHECK：控制字段的值的范围



**MySQL关联查询**









**MySQL中in和exist区别**

mysql中in语句把外表和内表做hash连接，而exists语句是对外表做loop，每次loop循环再对内表进行查询；

如果查询的两个表大小相当，用in或exists差别不大；

如果两个表一个大一个小，则子查询表大的用exists，子查询表小的用in；

not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not exists的子查询能用到表上的索引，所以用not exists比not in要快；



**drop、delete与truncate的区别**

drop：属于DDL，删除表结构，所有的数据行、索引和权限也会被删除，不可回滚，删除速度快；

delete：DML，不删除表结构，删除表的全部或部分数据行；删除速度慢；不会调整高水位；

truncate：DDL，不删除表结构，删除表中全部数据，删除速度快，会调整高水位；







**SQL的执行顺序**

FROM：将数据从硬盘加载到数据缓冲区；

WHERE：从基表或视图中选择满足条件的元组；

JOIN：例如右连接，从右边表中读取某个元组，并找到该元组在左表中对应的元组；

ON：join on 实现多表连接查询，推荐使用该种方式进行多表查询；

GROUP BY：分组，一般和聚合函数一起使用；

HAVING：在元组的基础上进行筛选，选出符合条件的元组；

SELECT：查询到所有元组需要罗列的哪些列；

DISTINCT：去重；

UNION：将多个查询结果合并（默认去掉重复的记录）；

ORDER BY：进行相应的排序；

LIMIT 1：显示输出一条数据记录（元组）








































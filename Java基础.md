集合

List

​	ArrayList 底层实现是数组，默认大小是10，扩容系数1.5，查询时时间复杂度O(1)

​	LinkedList 双向链表，好处是不用扩容，劣势，由于是链表查询时间复杂度是O(n)



Map

​	HashMap 底层实现   默认数组大小是2的幂次方倍，如果定义的大小不是2的指数，则会就近取比它大的2的指数倍，数组每个元素是链表，出现哈希冲突时往链表追加，1.8后 链表元素增加到8后变红黑树

​	

​	当HashMap中大量元素放到同一个桶中时，HashMap相当于一个单链表，遍历的复杂度为O(n)，失去了优势;

​	红黑树在二叉查找树的基础上增加了着色和一些性质使红黑树相对平衡，保证了红黑树的查找、插入、删除的时间复杂度最坏为O(logn)







​	红黑树

​	LinkedHashMap  增加了链表，在每一个元素加了个指针，指向下一个加入的元素，可根据插入顺序遍历

​	TreeMap 底层是红黑树

​	并发方向

​	HashTable 线程安全，线程写操作时整个存储结构锁住

​	ConcurrentHashMap 线程安全，concurrent包下，只锁住当前的桶，其他桶内可以正常操作，粒度变小

Set（不常）

HashSet  用HAshMap实现，用了HashMap的key，value为null





线程

如何创建

​	继承Thread类

​	实现Runnable

​	线程池

​		有哪几个

​		创建线程池的方法，参数



锁/同步问题

​	同步关键字，可修饰一段代码或方法，不够灵活所以有lock接口

​	读写锁 

​		读读不互斥，读写、写和其他操作会互斥

​		如何避免写饥饿



​	ThreadLocal

​		

​		实现原理

​			存在Thread对象中的一个属性 ThreadLocalMap，当前的ThreadLocal是key，需要设置的值是value，值在map中是弱引用

​			各种引用：弱引用、强引用、虚引用和软引用

​			弱引用的关系，哪些场景会内存泄露，如何避免

​		底层存储



原子性 

​	i++不是原子性

​	Auto类

可见性

​	volatile

JVM

内存模型

GC

类加载过程 分哪几步

双亲委派机制

打破双亲委派











---

 一个桶的树化阈值为8，当桶中元素个数超过这个值时，需要使用红黑树节点替换链表节点；
 一个树的链表还原阈值为6，当扩容时，桶中元素个数小于这个时就会把树还原为链表结构；
 哈希表的最小树化容量为64，当哈希表中的容量大于这个值时，桶才能进行树形化；

---



BST 二叉搜索树，一个节点的左子树的节点值都比它小，右子树的节点值都比它大

AVL 自平衡二叉树，左右子树的高度相差小于等于1

Red-Black Tree 红黑树，

特性：

节点都是红节点或黑节点

根节点必须是黑节点

叶子节点（null节点）必须是黑节点（也就是所有节点的一半以上是黑节点）；

红节点的子节点必须是黑节点；

新插入的节点是红节点；

从一个节点出发到叶子节点的所有路径上，所拥有的黑节点数必须是一样的；



AVL的平衡，条件比较苛刻

红黑树的平衡，深度差一倍以内



红黑树查询O(logn)

HashMap中桶内链表的长度达到8就会变成红黑树



---



##### Object类中的方法：

`registerNatives()` 	私有方法

`getClass()`					返回此Object的运行类

`hashCode()`					用于获取对象的哈希值

`equals(Object obj)`		用于确认两个对象是否”相等“

`clone()`						  创建并返回此对象的一个副本

`toString()`					返回该对象的字符串表示

`notify()`						唤醒在此对象监视器等待的单个线程

`notifyAll()`				  唤醒在此对象监视器等待的所有线程

`wait(long timeout)`	在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量前，导致当前线程等待。

`wait(long timeout,int nanos)`	在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。

`wait()`							用于让当前线程失去操作权限，当前线程进入等待序列

`finalize()`					当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法



---

shell中特殊变量

`$0`	shell或shell脚本的名字

`$*`	以一对双引号给出参数列表

`$@`	将各个参数分别加双引号返回

`$#`	参数的个数

`$_`	代表上一个命令的最后一个参数

`$$`	代表所在命令的PID

`$!`	代表最后执行的后台命令的PID

`$?`	代表上一个命令执行后的退出状态 echo $? 如果返回0，就是成功，返回其他就是失败



---

基本型（int）和基本型的封装型（Integer）进行“==”比较时，封装型会自动拆箱变为基本型再进行比较，以为true



Java8 接口中的方法 只能用 public、abstract、default、static修饰，被static修饰的方法必须有方法体；




































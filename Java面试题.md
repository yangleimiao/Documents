# Java面试题

### Java集合22题

1. ArrayList 和 Vector 的区别。

2. 说说 ArrayList,Vector, LinkedList 的存储性能和特性。

   ArrayList是一个可改变大小的数组，当更多元素加入到ArrayList中时大小将会动态增长，本质上是一个数组；

   LinkedList是一个双链表，在添加和删除元素时具有比ArrayList更好的性能，但get、set比ArrayList弱；

   Vector和ArrayList类似，但属于强同步类；

   Vector和ArrayList在更多元素添加进来时会请求更大的空间，Vector请求其大小的双倍空间，而ArrayList每次size增长50%；

3. 快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？

   fail-fast：在做系统设计时先考虑异常情况，一旦发生异常，直接停止并上报，在java中指的是集合中的错误检测机制，当多个线程对部分集合进行改变时，有可能触发fail-fast机制，这时会抛出ConcurrentModificationException

   Fail-safe：为了避免fail-fast机制，可以使用一些提供fail-safe的集合类，这样的集合容器在遍历时是先复制原有集合的内容，在拷贝的集合上进行遍历；

   

4. hashmap 的数据结构。

   就是将数组和链表组合在一起，数组寻址容易、插入删除困难，链表寻址困难、插入删除容易，常用的哈希函数就是用一种链地址法把数组和链表组合起来

5. HashMap 的工作原理是什么?

   HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象；当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashCode，然后找到bucket位置来储存值对象，当获取对象时，通过键对象的equals()找到正确的键值对，然后返回值对象，HashMap使用链表解决碰撞问题，当发生碰撞时，对象将会储存在链表的下一个节点，HashMap在每个链表节点中储存键值对对象。

   * 当两个对象的hashcode相同会发生什么？

     因为hashcode相同，所以它们的bucket位置相同，会发生碰撞，因为hashMap使用链表存储对象，这个Entry会存储在链表中。

     

6. Hashmap 什么时候进行扩容呢？

   当HashMap的元素个数（size）超过临界值（threshold）时就会自动扩容；

   临界值threshold=loaFactor*capacity

7. List、Map、Set 三个接口，存取元素时，各有什么特点？

   List特点：元素有放入顺序，可重复

   Set：无放入顺序，元素不可重复

8. Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用 == 还是 equals()? 它们有何区别?

   用equals()方法判断； 

   == 用来比较两个变量的值是否相等，也就是用于比较变量对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作；

   如果一个变量指向的数据是对象类型，这时涉及两块内存，对象本身占用一块内存（堆内存），变量也占用一块内存，（例如Object obj = new Object()），变量obj是一个内存，new Object()是另一块，变量obj对应的内存中存储的是对象占用的内存的地址，对于指向对象类型的变量，如果比较两个对象是否指向同一个对象，需要用==比较；

   equals()用于比较两个独立对象的内容是否相同；

9. 两个对象值相同 (x.equals(y) == true)，但却可有不同的 hash code，这句话对不对?

10. heap 和 stack 有什么区别。

    缓存方式区别：栈使用一级缓存，通常是被调用时处于存储空间，调用完立即释放；堆是存在二级缓存，生命周期由虚拟机的垃圾回收算法决定；

    堆栈数据结构区别：堆：可以看成是一棵树；栈：一种先进后出的数据结构；

    堆和栈都是Java用来在RAM中存放数据的地方；

    区别：

    堆：Java的堆是一个运行时数据区，类的对象从堆中分配空间，这些对象通过new等指令建立，通过垃圾回收器销毁；

    堆的优势是可以动态分配内存空间，缺点是由于需要在运行时分配内存，所以存取速度慢；

    栈：栈中主要存放一些基本数据类型的变量和对象的引用；

    栈的优势是存取速度快，栈数据可以共享，缺点是存放在栈中的数据占用的内存空间需要在编译时确定下来；

    

11. Java 集合类框架的基本接口有哪些？

12. HashSet 和 TreeSet 有什么区别？

    TreeSet 是二叉树实现的，TreeSet中的数据自动排好序，不允许null值；（TreeSet的底层是TreeMap的keySet()，而TreeMap是基于红黑树实现的，红黑树是一种平衡二叉查找树，任何一个节点的左右子树的高度都不会超过较矮那棵的一倍）

    HashSet的数据是无序的，可以放入一个null；两者都不能有重复值

13. HashSet 的底层实现是什么?

    HashSet底层是用HashMap存储数据的，当向HashSet添加元素的时候，首先计算元素的hashcode，然后通过扰动计算和按位与的方式计算出这个元素的存储位置，如果这个位置为空，就将元素添加进去，如果不为空，则用equals()比较元素是否相等，相等就不添加，否则就找空位添加

14. LinkedHashMap 的实现原理?

15. 为什么集合类没有实现 Cloneable 和 Serializable 接口？

16. 什么是迭代器 (Iterator)？

17. Iterator 和 ListIterator 的区别是什么？

18. 数组 (Array) 和列表 (ArrayList) 有什么区别？什么时候应该使用 Array 而不是 ArrayList？

    

19. Java 集合类框架的最佳实践有哪些？

20. Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用 == 还是 equals()？它们有何区别？

21. Comparable 和 Comparator 接口是干什么的？列出它们的区别

    两者都是用来实现集合中元素的比较、排序；

    Comparable是在集合内部定义的方法实现的排序，位于java.util下；

    Comparator是集合外部实现的排序，位于java.lang下；

    Comparable是一个对象本身就已经支持自比较所需要实现的接口，

    Comparator是一个专用的比较器，当这个对象不支持自比较或自比较函数不满足要求时，可以写一个比较器完成两个对象之间比较大小；

    

22. Collection 和 Collections 的区别。

    Collection是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，Collection是list，set等的父接口；

    Collections是一个包装类，它包含各种有关集合操作的静态多态方法，不能实例化，就像一个工具类





### **JVM与调优21题**

1. Java 类加载过程？

   类加载的过程主要分三步：加载、链接、初始化；

   加载指的是把.class文件通过类加载器加载进内存；

   链接分三小步：验证、准备、解析；

   验证：对文件格式、元数据、字节码和符号引用的验证；

   准备：主要为类变量分配内存，并赋予默认值；

   解析：将常量池内的符号引用替换成为直接引用的过程；

   初始化：这个阶段主要对类变量初始化；

   

   类的装载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构；类的加载的最终产品是位于堆区的Class对象，Class对象封装了类在方法区内的数据结构，并且提供了访问方法区内的数据结构的接口；

   

   验证：验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，大致会完成四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证；

   **文件格式验证**：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的目的是保证输入的字节流能正确解析并存储于方法区之内，经过该阶段的验证后，字节流才会进入内存的方法区中进行储备，后面的三个验证都是基于方法区的存储结构进行的；

   **元数据验证**：对类的元数据信息进行语义校验（对类中各数据类型进行语法校验），保证不存在不符个Java语法规范的元数据信息；

   **字节码验证**：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为；

   **符号引用验证**：这是最后一个阶段的验证，它发生在虚拟机将符号引用转换为直接引用的时候，主要对类自身以外的信息（常量池中的各种符号引用）进行匹配性校验；

   

   **准备**：正式为类变量分配内存并设置类变量初始值的阶段；

   进行内存分配的仅包括类变量，不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中；

   设置的是数据类型的默认值；

   

   **解析**：虚拟机将常量池内的符号引用替换为直接引用的过程；

   符号引用

   

   

2. 描述一下 JVM 加载 Class 文件的原理机制?

3. Java 内存分配。

4. GC 是什么? 为什么要有 GC？

5. 简述 Java 垃圾回收机制

6. 如何判断一个对象是否存活？（或者 GC 对象的判定方法）

7. 垃圾回收的优点和原理。并考虑 2 种回收机制

8. 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？

9. Java 中会存在内存泄漏吗，请简单描述

10. 深拷贝和浅拷贝。

11. System.gc() 和 Runtime.gc() 会做什么事情？

12. finalize() 方法什么时候被调用？析构函数 (finalization) 的目的是什么？

13. 如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存？

14. 什么是分布式垃圾回收（DGC）？它是如何工作的？

15. 串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？

16. 在 Java 中，对象什么时候可以被垃圾回收？

17. 简述 Java 内存分配与回收策率以及 Minor GC 和 Major GC。

18. JVM 的永久代中会发生垃圾回收么？

19. Java 中垃圾收集的方法有哪些？

20. 什么是类加载器，类加载器有哪些？

    启动类加载器 Bootstrap ClassLoader：它会加载$JAVA_HOME/jrelib下的文件

    扩展类加载器 ExtClassLoader：会加载$JAVA_HOME/jre/lib/ext目录下的文件

    应用程序类加载器 AppClassLoader：应用类加载器，会加载由System.getProperty("java.class.path")指定目录下的文件，也就是通常说的classpath路径

21. 类加载器双亲委派模型机制？

    当一个类加载器接收到类加载请求时，首先会请求其父类加载器加载，每一次都是如此，如果到顶层还无法找到这个类，就往下层返回，子类加载器尝试去加载





### 并发编程28题

1. Synchronized 用过吗，其原理是什么？
2. 你刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？
3. 什么是可重入性，为什么说 Synchronized 是可重入锁？
4. JVM 对 Java 的原生锁做了哪些优化？48
5. 为什么说 Synchronized 是非公平锁？49
6. 什么是锁消除和锁粗化？49
7. 为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？
8. 乐观锁一定就是好的吗？
9. 跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？
10. 那么请谈谈 AQS 框架是怎么回事儿？
11. 请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。
12. ReentrantLock 是如何实现可重入性的？
13. 除了 ReetrantLock，你还接触过 JUC 中的哪些并发工具？
14. 请谈谈 ReadWriteLock 和 StampedLock。
15. 如何让 Java 的线程彼此同步？你了解过哪些同步器？请分别介绍下。
16. CyclicBarrier 和 CountDownLatch 看起来很相似，请对比下呢？
17. Java 线程池相关问题
18. Java 中的线程池是如何实现的？
19. 创建线程池的几个核心构造参数？
20. 线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？
21. 既然提到可以通过配置不同参数创建出不同的线程池，那么 Java 中默认实现好的线程池又有哪些呢？请比较它们的异同
22. 如何在 Java 线程池中提交线程？
23. 什么是 Java 的内存模型，Java 中各个线程是怎么彼此看到对方的变量的？
24. 请谈谈 volatile 有什么特点，为什么它能保证变量对所有线程的可见性？
25. 既然 volatile 能够保证线程间的变量可见性，是不是就意味着基于 volatile 变量的运算就是并发安全的？
26. 请对比下 volatile 对比 Synchronized 的异同。
27. 请谈谈 ThreadLocal 是怎么解决并发安全的？
28. 很多人都说要慎用 ThreadLocal，谈谈你的理解，使用 ThreadLocal 需要注意些什么？

### spring 25题

- 1、什么是 Spring 框架？Spring 框架有哪些主要模块？
- 2、使用 Spring 框架能带来哪些好处？
- 3、什么是控制反转(IOC)？什么是依赖注入？
- 4、请解释下 Spring 框架中的 IoC？
- 5、BeanFactory 和 ApplicationContext 有什么区别？
- 6、Spring 有几种配置方式？
- 7、如何用基于 XML 配置的方式配置 Spring？
- 8、如何用基于 Java 配置的方式配置 Spring？
- 9、怎样用注解的方式配置 Spring？
- 10、请解释 Spring Bean 的生命周期？
- 11、Spring Bean 的作用域之间有什么区别？
- 12、什么是 Spring inner beans？
- 13、Spring 框架中的单例 Beans 是线程安全的么？
- 14、请举例说明如何在 Spring 中注入一个 Java Collection？
- 15、如何向 Spring Bean 中注入一个 Java.util.Properties？
- 16、请解释 Spring Bean 的自动装配？
- 17、请解释自动装配模式的区别？
- 18、如何开启基于注解的自动装配？
- 19、请举例解释@Required 注解？
- 20、请举例解释@Autowired 注解？
- 21、请举例说明@Qualifier 注解？
- 22、构造方法注入和设值注入有什么区别？
- 23、Spring 框架中有哪些不同类型的事件？
- 24、FileSystemResource 和 ClassPathResource 有何区别？
- 25、Spring 框架中都用到了哪些设计模式？



### 设计模式 10题

1. 什么是设计模式？你是否在你的代码里面使用过任何设计模式？

2. Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式

   保证一个类只有一个实例，并提供一个访问该全局访问点

3. 在 Java 中，什么叫观察者设计模式（observer design pattern）？

   观察者模式是一种行为性模式，它定义对象之间一种一对多的依赖关系，使得当一个对象改变状态，则所有依赖于它的对象都得到通知并自动更新；

4. 使用工厂模式最主要的好处是什么？在哪里使用？

   * 利用工工厂模式可以降低程序的耦合性，为后期的维护修改提供了很大便利；

   * 将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦；

- 6.举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？

- 7.在 Java 中，为什么不允许从静态方法中访问非静态变量？

- 8.设计一个 ATM 机，请说出你的设计思路？

- 9.在 Java 中，什么时候用重载，什么时候用重写？

  

- 10.举例说明什么情况下会更倾向于使用抽象类而不是接口



### springboot 22题

1. 什么是 Spring Boot？

   Spring开源组织下的子项目，主要简化了使用Spring的难度，简化了繁重的配置，提供了各种启动器，可以快速上手

2. Spring Boot 有哪些优点？

   * 易上手，提高了开发效率；
   * 开箱即用，远离繁琐的配置；
   * 提供了一系列大型项目通用的非业务性功能，例如内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等；
   * 不需要xml配置；
   * 避免大量的Maven导入和版本冲突；

3. 什么是 JavaConfig？

   Spring JavaConfig是Spring社区的产品，提供了配置Spring IOC容器的Java方法，可以避免XML配置；

   * 优点：

     * 面向对象的配置，由于配置被定义为JavaConfig中的类，因此用户可以利用Java中的面向对象功能，一个配置类可以继承另一个重写@Bean方法；

     * 减少或消除XML配置，JavaConfig提供了Java方法来配置Spring容器；
     * 类型安全和重构友好，JavaConfig提供了一种类型安全的方法来配置Spring容器；

     

4. 如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？

5. Spring Boot 中的监视器是什么？

    Spring Boot Actuator 

6. 如何在 Spring Boot 中禁用 Actuator 端点安全性？

   默认情况下，所有敏感的HTTP端点都是安全的，只有具有ACTUATOR角色的用户才能访问它们

   安全性是使用标准的HttpServletRequest.isUserInRole方法湿湿的，可以使用`management.security.enabled=false`来禁用安全性

7. 如何在自定义端口上运行 Spring Boot 应用程序？

   在application.properties中指定端口

8. 什么是 YAML？

   是一种数据序列化语言，通常用于配置文件，yaml文件更加结构化，而且具有分层配置

9. 如何实现 Spring Boot 应用程序的安全性？

   使用`spring-boot-starter-security`依赖项，并且必须添加安全配置；配置类必须扩展`WebSecurityConfigurerAdapter`并覆盖其方法；

10. 如何集成 Spring Boot 和 ActiveMQ？

    使用`spring-boot-starter-activemq`依赖关系；

11. 如何使用 Spring Boot 实现分页和排序？

    使用Spring Data-JPA 可以实现将可分页的`org.springframework.data.domain.Pageable`传递给存储库方法；

12. 什么是 Swagger？你用 Spring Boot 实现了它吗？

    Swagger是用于生成RESTful Web服务的可视化表示工具

13. 什么是 Spring Profiles？

    Spring Profiles允许用户根据不同配置文件来注册bean，比如当应用程序在开发中运行时，只有某些bean可以加载；

14. 什么是 Spring Batch？

     

15. 什么是 FreeMarker 模板？

16. 如何使用 Spring Boot 实现异常处理？

     Spring提供了一种使用ControllerAdvice处理异常的方法，通过实现一个ControllerAdvice类，来处理控制器类抛出的所有异常；

17. 您使用了哪些 starter maven 依赖项？

18. 什么是 CSRF 攻击？

     CSRF代表跨站请求伪造，是一种迫使最终用户在当前通过身份验证的Web应用程序上执行不需要的操作的攻击，专门针对状态改变请求，而不是数据窃取

19. 什么是 WebSockets？

20. 什么是 AOP？

21. 我们如何监视所有 Spring Boot 微服务？

22. Spring Boot的核心注解是哪个？主要由哪几个注解组成？

     @SpringBootApplication 是启动类上的注解，也是Spring Boot 的核心注解，主要包含了：

     `@SpringBootConfiguration`：组合了`@Configuration`注解，实现配置文件的功能；

     `@EnableAutoConfiguration`：打开自动配置的功能，也可以关闭某个自动配置的选项；

     `@ComponentScan`：Spring组件扫描；



### Netty10题

1. BIO、NIO和AIO的区别？

   * BIO是阻塞的，NIO是非阻塞的；
   * BIO是面向流 ，只能单向读写，NIO是面向缓存的，可以双向读写；
   * 使用BIO做Socket连接时，由于单向读写，当没有数据时，会挂起当前线程，阻塞等待，为防止影响其它连接,，需要为每个连接新建线程处理.，然而系统资源是有限的,，不能过多的新建线程，线程过多带来线程上下文的切换，从来带来更大的性能损耗，因此需要使用NIO进行BIO多路复用，使用一个线程来监听所有Socket连接，使用本线程或者其他线程处理连接
   * AIO是非阻塞，以异步方式发起IO操作，当IO操作进行时可以去做其他操作，由操作系统内核空间提醒IO操作已完成；

   

2. BIO、NIO和AIO

   * BIO：同步并阻塞，服务器实现一个连接一个线程，即客户端有连接请求时服务端就需要启动一个线程进行处理，处理完之前此线程不能做其他操作；BIO适用于连接数目比较小且固定的架构；
   * NIO：同步非阻塞，服务器实现一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求时才启用一个线程进行处理；NIO方式适用于连接数目多且连接比较短的架构
   * AIO：异步并阻塞，服务器实现模式为一个有效请求一个线程，客户端的IO请求都是由操作系统先完成了再通知服务器应用去启动线程进行处理，AIO方式适用于连接数目多且连接比较长的架构；

3. 五种IO模型？

   * 阻塞BIO（Blocking I/O）：在内核将数据准备好之前，系统调用会一直等待所有的套接字，默认是阻塞方式；
   * 非阻塞NIO（noblcking I/O）：使用轮询的方式；
   * 异步AIO（asynchronous I/O）：当应用程序请求数据时，内核一方面去取数据报内容返回，另一方面将程序控制权还给应用进程，应用进程继续处理其他事情，是一种非阻塞的状态；
   * 信号驱动IO（signal blocking I/O）：应用程序告诉内核：当数据报准备好时，给我发送一个信号，应用程序对SIGIO信号进行捕捉，并且调用信号处理函数来获取数据报；
   * IO多路转接（I/O multiplexing）：IO多路转接是多了一个select函数，select函数有一个参数是文件描述符集合，对这些文件描述符进行循环监听，当某个文件描述符就绪时，就对这个文件描述符进行处理；IO多路转接属于阻塞IO，但可以对多个文件描述符进行阻塞监听，所以效率高于阻塞IO

4. 在实现序列化接口时一般要生成一个serialVersionUID，它的作用？

   如果用户没有自己声明一个serialVersionUID，接口会默认生成一个serialVersionUID；

   默认的serialVersionUID对于class的细节非常敏感，反序列化时可能会导致InvalidClassExcepion异常，所以建议自定义；

5. NIO的组成？

   Buffer：与Channel进行交互，数据是从Channel读入缓冲区，从缓冲区写入Channel中的

   flip方法 ： 反转此缓冲区，将position给limit，然后将position置为0，其实就是切换读写模式

   clear方法 ：清除此缓冲区，将position置为0，把capacity的值给limit。

   rewind方法 ： 重绕此缓冲区，将position置为0

   DirectByteBuffer可减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高，不可控，通常会用内存池来提高性能。直接缓冲区主要分配给那些易受基础系统的本机I/O 操作影响的大型、持久的缓冲区。如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer，由JVM进行管理。

   Channel：表示 IO 源与目标打开的连接，是双向的，但不能直接访问数据，只能与Buffer 进行交互。通过源码可知，FileChannel的read方法和write方法都导致数据复制了两次！

   Selector可使一个单独的线程管理多个Channel，open方法可创建Selector，register方法向多路复用器器注册通道，可以监听的事件类型：读、写、连接、accept。注册事件后会产生一个SelectionKey：它表示SelectableChannel 和Selector 之间的注册关系，wakeup方法：使尚未返回的第一个选择操作立即返回，唤醒的

   原因是：注册了新的channel或者事件；channel关闭，取消注册；优先级更高的事件触发（如定时器事件），希望及时处理。

   Selector在Linux的实现类是EPollSelectorImpl，委托给EPollArrayWrapper实现，其中三个native方法是对epoll的封装，而EPollSelectorImpl. implRegister方法，通过调用epoll_ctl向epoll实例中注册事件，还将注册的文件描述符(fd)与SelectionKey的对应关系添加到fdToKey中，这个map维护了文件描述符与SelectionKey的映射。

   fdToKey有时会变得非常大，因为注册到Selector上的Channel非常多（百万连接）；过期或失效的Channel没有及时关闭。fdToKey总是串行读取的，而读取是在select方法中进行的，该方法是非线程安全的。

   Pipe：两个线程之间的单向数据连接，数据会被写到sink通道，从source通道读取

   NIO的服务端建立过程：Selector.open()：打开一个Selector；ServerSocketChannel.open()：创建服务端的Channel；bind()：绑定到某个端口上。并配置非阻塞模式；register()：注册Channel和关注的事件到Selector上；select()轮询拿到已经就绪的事件

6. Netty的特点？

7. Netty的线程模型？

   Netty通过Reator模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss线程池和work线程池，其中boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件，由对应的Handler处理；

   单线程模型：所有IO操作都由一个线程完成，即多路复用、事件分发和处理都是在一个Reactor线程上完成的。既要接收客户端的连接请求,向服务端发起连接，又要发送/读取请求或应答/响应消息。一个NIO 线程同时处理成百上千的链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适。

   多线程模型：有一个NIO 线程（Acceptor） 只负责监听服务端，接收客户端的TCP 连接请求；NIO 线程池负责网络IO 的操作，即消息的读取、解码、编码和发送；1 个NIO 线程可以同时处理N 条链路，但是1 个链路只对应1 个NIO 线程，这是为了防止发生并发操作问题。但在并发百万客户端连接或需要安全认证时，一个Acceptor 线程可能会存在性能不足问题。

   主从多线程模型：Acceptor 线程用于绑定监听端口，接收客户端连接，将SocketChannel 从主线程池的Reactor 线程的多路复用器上移除，重新注册到Sub 线程池的线程上，用于处理I/O 的读写等操作，从而保证mainReactor只负责接入认证、握手等操作；

8. TCP 粘包/拆包的原因及解决方法？

   TCP是以字节流的方式处理数据，一个完整的包可能被拆成多个包，也可能多个包合成一个；

   应用程序希尔的字节大小大于发送缓冲区大小时，会发生拆包现象；应用程序写入数据大小小于发送缓冲区，网卡将多次写入的数据发送到网络上将会发生粘包；

   解决：

   * 消息定长：FixedLengthFrameDecoder类

   * 包尾增加特殊字符分割：

     行分隔符类：LineBasedFrameDecoder

     自定义分隔符类：DelimiterBasedFrameDecoder

   * 将消息分为消息头和消息体：LengthFieldBasedFrameDecoder类

   

9. 了解哪几种序列化协议？

10. 如何选择序列化协议？

11. Netty的零拷贝实现？

    * Netty的接收和发送ByteBuffer采用DIRECTBUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝，如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝到直接内存中，然后才写入Socket中，相比于堆外直接内存，消息在发送过程中多列一次缓冲区的内存拷贝
    * Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer
    * Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题

12. Netty的高性能表现在哪些方面？

    Netty作为异步事件驱动的网络，高性能之处主要来自于I/O模型和线程处理模型，前者决定如何收发数据，后者决定如何处理数据

    * I/O复用模型中，会用到select，这个函数也会使进程阻塞，但是这个函数可以同时阻塞多个I/O操作，而且可以同时对多个读操作、写操作的I/O函数进行检测，直到有数据可读或可写，才真正调用I/O操作函数；Netty的非阻塞I/O的实现关键是基于I/O复用模型；

      Netty的IO线程NioEventLoop由于聚合了多路复用器Selector，可以同时并发处理成百上千个客户端连接，当线程从某客户端Socket通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务，线程通常将非阻塞IO的空闲时间用于在其他通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道；

      由于读写操作都是非阻塞的，这就可以充分提升IO线程的运行效率，避免由于频繁I/O阻塞导致的线程挂起，一个I/O线程可以并发处理N个客户端连接和读写操作，这从根本上解决了传统同步阻塞I/O一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。

      在NIO中, 抛弃了传统的 I/O流, 而是引入了Channel和Buffer的概念. 在NIO中, 只能从Channel中读取数据到Buffer中或将数据 Buffer 中写入到 Channel。

      基于buffer操作不像传统IO的顺序操作, NIO 中可以随意地读取任意位置的数据；

    * 事件驱动模型：

    

    

13. NIOEventLoopGroup源码？

    NIOEventLoopGroup内部维护了一个类型为EventExecutor 的变量children[]，默认大小是处理器核数*2，这样就构成了一个线程池，初始化EventExecutor时NIOEventLoopGroup重载newChile方法，所以children元素的实际类型为NIOEventLoop；

    线程启动时调用SingleThreadEventExecutor的构造方法，执行NIOEventLoop类的run方法，首先会调用hasTasks()方法判断当前taskQueue是否有元素。如果taskQueue中有元素，执行 selectNow() 方法，最终执行selector.selectNow()，该方法会立即返回。如果taskQueue没有元素，执行 select(oldWakenUp) 方法

    select ( oldWakenUp) 方法解决了 Nio 中的 bug，selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()，若触发了epoll的空轮询bug，则会反复执行selector.select(timeoutMillis)，变量selectCnt 会逐渐变大，当selectCnt 达到阈值（默认512），则执行rebuildSelector方法，进行selector重建，解决cpu占用100%的bug。

    rebuildSelector方法先通过openSelector方法创建一个新的selector。然后将old selector的selectionKey执行cancel。最后将old selector的channel重新注册到新的selector中。rebuild后，需要重新执行方法selectNow，检查是否有已ready的selectionKey。

    接下来调用processSelectedKeys 方法（处理I/O任务），当selectedKeys != null时，调用processSelectedKeysOptimized方法，迭代 selectedKeys 获取就绪的 IO 事件的selectkey存放在数组selectedKeys中, 然后为每个事件都调用 processSelectedKey 来处理它，processSelectedKey 中分别处理OP_READ；OP_WRITE；OP_CONNECT事件。

    最后调用runAllTasks方法（非IO任务），该方法首先会调用fetchFromScheduledTaskQueue方法，把scheduledTaskQueue中已经超过延迟执行时间的任务移到taskQueue中等待被执行，然后依次从taskQueue中取任务执行，每执行64个任务，进行耗时检查，如果已执行时间超过预先设定的执行时间，则停止执行非IO任务，避免非IO任务太多，影响IO任务的执行。

    每个NioEventLoop对应一个线程和一个Selector，NioServerSocketChannel会主动注册到某一个NioEventLoop的Selector上，NioEventLoop负责事件轮询。

    Outbound 事件都是请求事件, 发起者是 Channel，处理者是 unsafe，通过 Outbound 事件进行通知，传播方向是 tail到head。Inbound 事件发起者是 unsafe，事件的处理者是 Channel, 是通知事件，传播方向是从头到尾。

    内存管理机制，首先会预申请一大块内存Arena，Arena由许多Chunk组成，而每个Chunk默认由2048个page组成。Chunk通过AVL树的形式组织Page，每个叶子节点表示一个Page，而中间节点表示内存区域，节点自己记录它在整个Arena中的偏移地址。当区域被分配出去后，中间节点上的标记位会被标记，这样就表示这个中间节点以下的所有节点都已被分配了。大于8k的内存分配在poolChunkList中，而PoolSubpage用于分配小于8k的内存，它会把一个page分割成多段，进行内存分配。

    ByteBuf的特点：支持自动扩容（4M），保证put方法不会抛出异常、通过内置的复合缓冲类型，实现零拷贝（zero-copy）；不需要调用flip()来切换读/写模式，读取和写入索引分开；方法链；引用计数基于AtomicIntegerFieldUpdater用于内存回收；PooledByteBuf采用二叉树来实现一个内存池，集中管理内存的分配和释放，不用每次使用都新建一个缓冲区对象。UnpooledHeapByteBuf每次都会新建一个缓冲区对象。





### Redis 16题

1. 什么是redis?

   Redis 是一个使用 C 语言写成的，开源的高性能key-value非关系缓存数据库。它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。Redis的数据都基于缓存的，所以很快，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。Redis也可以实现数据写入磁盘中，保证了数据的安全不丢失，而且Redis的操作是原子性的；

2. Reids的特点

   

3. Redis支持的数据类型

   Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求

   | 数据类型 |      可以存储的值      |                             操作                             |                           应用场景                           |
   | :------: | :--------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
   |  String  | 字符串、整数或者浮点数 | 对整个字符串或者字符串的其中一部分执行操作 对整数和浮点数执行自增或者自减操作 |                      做简单的键值对缓存                      |
   |   List   |          列表          | 从两端压入或者弹出元素 对单个或者多个元素进行修剪， 只保留一个范围内的元素 | 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的数据 |
   |   Set    |        无序集合        | 添加、获取、移除单个元素 检查一个元素是否存在于集合中 计算交集、并集、差集 从集合里面随机获取元素 | 交集、并集、差集的操作，比如交集，可以把两个人的粉丝列表整一个交集 |
   |   Hash   | 包含键值对的无序散列表 | 添加、获取、移除单个键值对 获取所有键值对 检查某个键是否存在 |                  结构化的数据，比如一个对象                  |
   |   ZSet   |        有序集合        | 添加、获取、删除元素 根据分值范围或者成员来获取元素 计算一个键的排名 |            去重但可以排序，如获取排名前几名的用户            |




4. 虚拟内存

   Redis的数据是保存在内存中，当物理内存不足，就会保存在虚拟内存（VM）中，Redis的vm类似操作系统的vm，其会把所有的键都存在内存中，而把部分很少被访问到的值放在硬盘中。

   当你的key很小而value很大时,使用VM的效果会比较好.因为这样节约的内存比较大.

   当你的key不小时,可以考虑使用一些非常方法将很大的key变成很大的value,比如你可以考虑将key,value组合成一个新的value.

5. Redis锁

6. 读写分离模型

   对于缓存而言，读的需求量远大于写的需求量，而读写分离的机制就是在主机上执行写操作，然后异步的将数据复制到从机上，而从机只负责读操作

7. 数据分片策略

   常用的数据分片的方法有：范围分片、哈希分片、一致性哈希算法、哈希槽等；

   * 范围分片假设数据集是有序，将顺序相临近的数据放在一起，可以很好的支持遍历操作。范围分片的缺点是面对顺序写时，会存在热点。比如日志类型的写入，一般日志的顺序都是和时间相关的，时间是单调递增的，因此写入的热点永远在最后一个分片。

   

   Redis Cluster采用虚拟哈希槽分区，所有的键根据哈希函数映射到0~16383槽内，计算公式为slot=CRC16(key)&16383，每一个节点负责维护一部分槽以及槽所映射的键值数据

   Redis虚拟槽分区的特点：

   - 解耦数据和节点之间的关系，简化了节点扩容和收缩难度。
   - 节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据
   - 支持节点、槽和键之间的映射查询，用于数据路由，在线集群伸缩等场景。

   

8. Redis的回收策略

9. 使用Redis有哪些好处？

   (1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都很低

   (2)支持丰富数据类型，支持string，list，set，sorted set，hash

   (3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行

   (4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除

   

10. redis常见性能问题和解决方案

    Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。

    如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。

    为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。

    尽量避免在压力较大的主库上增加从库

    Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。

    为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master<–Slave1<–Slave2<–Slave3…，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。

    

11. MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据

12. Memcache与Redis的区别都有哪些？

13. Redis 最适合的场景

    计数器

    可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。

    缓存

    将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。

    会话缓存

    可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。

    全页缓存（FPC）

    除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。

    查找表

    例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。

    消息队列(发布/订阅功能)

    List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。

    分布式锁实现

    在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。

    其它

    Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。


​    

14. Redis的内存淘汰策略有哪些

    ```
    Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。
    ```

    - 全局的键空间选择性移除
      - noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。
      - allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）
      - allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
    - 设置过期时间的键空间选择性移除
      - volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
      - volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
      - volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。
    - 总结

    ```
    Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。
    ```


​    

15. Redis的过期键的删除策略

    ```
    我们都知道，Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。
    ```

    - 过期策略通常有以下三种：
    - 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。
    - 惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。
    - 定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。 (expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)


​    

16. Redis 的持久化机制是什么？各自的优缺点？

    Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制:

    RDB：是Redis DataBase缩写快照

- RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。



![在这里插入图片描述](https://user-gold-cdn.xitu.io/2020/4/14/1717449419419e78?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



- 优点：

  1、只有一个文件 dump.rdb，方便持久化。

  2、容灾性好，一个文件可以保存到安全的磁盘。

  3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能

  4.相对于数据集大时，比 AOF 的启动效率更高。

- 缺点：

  1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)

  2、AOF（Append-only file)持久化方式： 是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件。

##### AOF：持久化：

- AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。
- 当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复



![在这里插入图片描述](https://user-gold-cdn.xitu.io/2020/4/14/171744941b1f2a80?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



- 优点：

  1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。

  2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。

  3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)

- 缺点：

  1、AOF 文件比 RDB 文件大，且恢复速度慢。

  2、数据集大的时候，比 rdb 启动效率低。

- 俩种持久化的优缺点是什么？

  - AOF文件比RDB更新频率高，优先使用AOF还原数据。
  - AOF比RDB更安全也更大
  - RDB性能比AOF好
  - 如果两个都配了优先加载AOF

  

20. Redis事务阶段、相关命令

    * 阶段：

      事务开始：MULTI；

      命令入队；

      事务执行 EXEC；

      > 事务执行过程中，如果服务端收到EXEC、DISCARD、WATCH、MULTI之外的请求，会把请求放到队列中排队

    * 相关命令：MULTI、EXEC、DISCARD和WATCH

      Redis会将一个事务中所有命令序列化，然后按照顺序执行；

      1. **redis 不支持回滚**，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。
      2. **如果在一个事务中的命令出现错误，那么所有的命令都不会执行**；
      3. **如果在一个事务中出现运行错误，那么正确的命令会被执行**。

      - WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。
      - MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。
      - EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。
      - 通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。
      - UNWATCH命令可以取消watch对所有key的监控。

    * 事务概述

      ```
      Redis的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在_AOF_持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。
      ```

    * Redis事务隔离性？

      Redis是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止，因此，Redis的事务是总是带隔离性的

21. 缓存异常

    * redis穿透：用户请求透过redis去请求mysql服务器，导致mysql压力过载；

      解决办法：

      * 从缓存取不到的数据，在数据库也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，这样可以防止供给用户反复用同一个id暴力攻击；
      * 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0直接拦截；
      * 采用布隆过滤器，将所有可能存在的数据哈希到足够大的bitmap中，一个一定不存在的数据会被拦截掉；

      

    * redis雪崩：redis服务由于负载过大而宕机，导致mysql的负载过大也宕机，最终整个系统瘫痪

      解决办法：

      * 使用redis集群；
      * 缓存预热（关闭外网访问，先开启mysql，通过预热脚本将热点数据写入缓存中，启动缓存，开启外网服务）；
      * 数据不要设置相同的生存时间，不然过期时，redis压力会大；

    * redis穿透：高并发下，由于一个key失效，导致多个线程去mysql查同一业务数据并存到redis（并发下，存了多份数据），而一段时间后，多份数据同时失效导致压力骤增；

      解决办法：

      * 分级缓存（缓存两份数据，第二份数据生存时间长一点作为备份，第一份数据用于被请求命中，如果第二份数据被命中说明第一份数据已经过期，要去mysql请求数据重新缓存两份数据）；
      * 计划任务（假如数据生存时间为30分钟，计划任务就20分钟执行一次更新缓存数据）；

      

    * 缓存预热

      缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题；

    * 缓存降级

      当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。

      **缓存降级**的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。

      在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：

      1. 一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；
      2. 警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；
      3. 错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；
      4. 严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。

      * 服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户；

    * 热点数据和冷数据

      - 热点数据，缓存才有价值
      - 对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存

    * 缓存热点key

      - 缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。

      * 解决方案

        对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询

      



























































